// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const fuzzySearch = `-- name: FuzzySearch :many
SELECT DISTINCT package.id,
                human_name,
                package.name,
                latest_version,
                description,
                keywords,
                homepage,
                developer
FROM package
         INNER JOIN public.variation v ON package.id = v.package_id
WHERE dmetaphone($1::text) ILIKE dmetaphone(human_name)
   OR dmetaphone($1::text) = ANY (ARRAY(SELECT dmetaphone(element) FROM unnest(keywords) AS element))
   OR dmetaphone($1::text) = ANY (ARRAY(SELECT dmetaphone(element) FROM unnest(developer) AS element))
   OR dmetaphone($1::text) ILIKE dmetaphone(human_name)
   OR dmetaphone($1::text) ILIKE dmetaphone(package.name)
   OR dmetaphone($1::text) ILIKE dmetaphone(description)
   OR dmetaphone($1::text) ILIKE dmetaphone(v.name)
`

func (q *Queries) FuzzySearch(ctx context.Context, term string) ([]Package, error) {
	rows, err := q.db.Query(ctx, fuzzySearch, term)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Package
	for rows.Next() {
		var i Package
		if err := rows.Scan(
			&i.ID,
			&i.HumanName,
			&i.Name,
			&i.LatestVersion,
			&i.Description,
			&i.Keywords,
			&i.Homepage,
			&i.Developer,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllPackages = `-- name: GetAllPackages :many
SELECT id,
    human_name,
    name,
    latest_version,
    description,
    keywords,
    homepage,
    developer
FROM package
`

func (q *Queries) GetAllPackages(ctx context.Context) ([]Package, error) {
	rows, err := q.db.Query(ctx, getAllPackages)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Package
	for rows.Next() {
		var i Package
		if err := rows.Scan(
			&i.ID,
			&i.HumanName,
			&i.Name,
			&i.LatestVersion,
			&i.Description,
			&i.Keywords,
			&i.Homepage,
			&i.Developer,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPackageFromID = `-- name: GetPackageFromID :one
SELECT id, human_name, name, latest_version, description, keywords, homepage, developer
FROM package
WHERE id = $1::numeric
`

func (q *Queries) GetPackageFromID(ctx context.Context, id pgtype.Numeric) (Package, error) {
	row := q.db.QueryRow(ctx, getPackageFromID, id)
	var i Package
	err := row.Scan(
		&i.ID,
		&i.HumanName,
		&i.Name,
		&i.LatestVersion,
		&i.Description,
		&i.Keywords,
		&i.Homepage,
		&i.Developer,
	)
	return i, err
}

const getVariations = `-- name: GetVariations :many
SELECT variation.id      AS id,
       package_id,
       distro_id,
       p.human_name      AS human_name,
       variation.name    AS name,
       variation.version AS version,
       package_url,
       download_url,
       d.name            AS distro_name,
       d.version         AS distro_version
FROM variation
         INNER JOIN distro d ON d.id = variation.distro_id
         INNER JOIN package p ON p.id = variation.package_id
WHERE package_id = $1::numeric
`

type GetVariationsRow struct {
	ID            int64
	PackageID     int64
	DistroID      int64
	HumanName     string
	Name          string
	Version       pgtype.Int8
	PackageUrl    pgtype.Text
	DownloadUrl   pgtype.Text
	DistroName    string
	DistroVersion pgtype.Text
}

func (q *Queries) GetVariations(ctx context.Context, packageID pgtype.Numeric) ([]GetVariationsRow, error) {
	rows, err := q.db.Query(ctx, getVariations, packageID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetVariationsRow
	for rows.Next() {
		var i GetVariationsRow
		if err := rows.Scan(
			&i.ID,
			&i.PackageID,
			&i.DistroID,
			&i.HumanName,
			&i.Name,
			&i.Version,
			&i.PackageUrl,
			&i.DownloadUrl,
			&i.DistroName,
			&i.DistroVersion,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
